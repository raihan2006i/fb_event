require 'spec_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.

describe RecommendationsController do

  # This should return the minimal set of attributes required to create a valid
  # Recommendation. As you add validations to Recommendation, be sure to
  # update the return value of this method accordingly.
  def valid_attributes
    {
      :recommender_social_account_name => "facebook_test",
      :recommender_social_account_type => SocialAccount::TYPE_FACEBOOK,
      :recommender_email => "recommender@example.com",
      :relation => Recommendation::EMPLOYEE,
      :request_text => "request_test"
    }
  end

  # This should return the minimal set of values that should be in the session
  # in order to pass any filters (e.g. authentication) defined in
  # RecommendationsController. Be sure to keep this updated too.
  def valid_session
    {}
  end


  before(:each) do
  end


  describe "GET index" do
    before(:each) do
      @recommendations = []
      @first_user = Factory(:confirmed_user)
      @second_user = Factory(:confirmed_user)

      [Recommendation::STATUS_PENDING, Recommendation::STATUS_DONE].each do |status|
        recommendation = Factory(:recommendation, :status => status)
        recommendation.recommendee = @first_user
        recommendation.recommender = @second_user
        recommendation.save(:validate => false)
        @recommendations << recommendation
      end

      [Recommendation::STATUS_PENDING, Recommendation::STATUS_DONE].each do |status|
        recommendation = Factory(:recommendation, :status => status)
        recommendation.recommendee = @second_user
        recommendation.recommender = @first_user
        recommendation.save(:validate => false)
        @recommendations << recommendation
      end
      @recommendations.sort_by! {|r| r.id}
      @pending_sent_recommendations = @recommendations.select { |r| r.recommendee == @first_user &&  r.status ==  Recommendation::STATUS_PENDING}.sort_by {|r| r.id}
      @done_sent_recommendations = @recommendations.select { |r| r.recommendee == @first_user &&  r.status ==  Recommendation::STATUS_DONE}.sort_by {|r| r.id}
      @pending_received_recommendations = @recommendations.select { |r| r.recommender == @first_user &&  r.status ==  Recommendation::STATUS_PENDING}.sort_by {|r| r.id}
      @done_received_recommendations = @recommendations.select { |r| r.recommender == @first_user &&  r.status ==  Recommendation::STATUS_DONE}.sort_by {|r| r.id}
    end

    it "recommendee can view his recommendations" do
      sign_in @first_user
      get :index, {:user_id => @first_user.id}
      assigns(:pending_sent_recommendations).sort_by {|r| r.id}.should eq(@pending_sent_recommendations)
      assigns(:done_sent_recommendations).sort_by {|r| r.id}.should eq(@done_sent_recommendations)
      assigns(:pending_received_recommendations).sort_by {|r| r.id}.should eq(@pending_received_recommendations)
      assigns(:done_received_recommendations).sort_by {|r| r.id}.should eq(@done_received_recommendations)
      assigns(:recommendations).sort_by {|r| r.id}.should eq(@recommendations)
    end

    it "recommender can not view recommendee recommendations" do
      sign_in @second_user
      get :index, {:user_id => @first_user.id}
      response.should redirect_to( user_recommendations_path(@second_user))
    end
    
  end

  describe "GET show" do
    before(:each) do
      @recommendation = Factory(:recommendation)
    end

    it "assigns the requested recommendation as @recommendation" do
      @recommendee = Factory(:confirmed_user)
      @recommendation.recommendee =  @recommendee
      @recommendation.save(:validate => false)
      sign_in @recommendee
      get :show, {:user_id => @recommendee.id, :id => @recommendation.id}
      assigns(:recommendation).should eq(@recommendation)
    end

    it "recommendee can access his recommendation" do
      @recommendee = Factory(:confirmed_user)
      @recommendation.recommendee =  @recommendee
      @recommendation.save(:validate => false)
      sign_in @recommendee
      get :show, {:user_id => @recommendee.id, :id => @recommendation.id}
      assigns(:recommendation).should eq(@recommendation)
      assigns(:can_access).should eq(true)
    end

    it "recommender can access recommendee recommendation" do
      @recommendee = Factory(:confirmed_user)
      @recommender = Factory(:confirmed_user)
      @recommendation.recommendee =  @recommendee
      @recommendation.recommender = @recommender
      @recommendation.save(:validate => false)
      sign_in @recommender
      get :show, {:user_id => @recommendee.id, :id => @recommendation.id}
      assigns(:recommendation).should eq(@recommendation)
      assigns(:can_access).should eq(true)
    end

    it "current_user can not access recommendation if he/she is not a recommendee or recommender" do
      @user = Factory(:confirmed_user)
      @recommendee = Factory(:confirmed_user)
      @recommender = Factory(:confirmed_user)
      @recommendation.recommendee =  @recommendee
      @recommendation.recommender = @recommender
      @recommendation.save(:validate => false)
      sign_in @user
      get :show, {:user_id => @recommendee.id, :id => @recommendation.id}
      assigns(:recommendation).should eq(@recommendation)
      assigns(:can_access).should eq(false)
    end
    
  end



  describe "GET new" do
    
    it "assigns a new recommendation as @recommendation" do
      @recommendee = Factory(:confirmed_user)
      sign_in @recommendee
      get :new, {:user_id => @recommendee.id}
      assigns(:recommendation).should be_a_new(Recommendation)
      assigns(:recommendation).recommendee.should eq(@recommendee)
    end

    it "should redirect back to current_user recommendations url if he/she try to create recommendation for different user" do
      @user = Factory(:confirmed_user)
      @recommendee = Factory(:confirmed_user)
      sign_in @user
      get :new, {:user_id => @recommendee.id}
      response.should redirect_to( user_recommendations_path(@user))
    end
    
  end

  describe "GET feedback" do
    before(:each) do
      @recommendation = Factory(:recommendation)
      @recommendee = Factory(:confirmed_user)
      @recommender = Factory(:confirmed_user)
      @recommendation.recommendee =  @recommendee
      @recommendation.recommender = @recommender
      @recommendation.save(:validate => false)
    end
    
    it "assigns the requested recommendation as @recommendation for recommender" do
      sign_in @recommender
      get :feedback, {:user_id => @recommendee.id, :id => @recommendation.to_param}
      assigns(:recommendation).should eq(@recommendation)
    end

    it "should redirect back to recommendee recommendations url if he/she try to give feedback on his own recommendation" do
      sign_in @recommendee
      get :feedback, {:user_id => @recommendee.id, :id => @recommendation.to_param}
      assigns(:can_access).should eq(false)
      response.should redirect_to( user_recommendations_path(@recommendee))
    end
  end

  describe "POST submit_feedback" do
    
    before(:each) do
      @recommendation = Factory(:recommendation)
      @recommendee = Factory(:confirmed_user)
      @recommender = Factory(:confirmed_user)
      @recommendation.recommendee =  @recommendee
      @recommendation.recommender = @recommender
      @recommendation.save(:validate => false)
    end

    it "updates the requested recommendation as done if feedback was given" do
      sign_in @recommender
      post :submit_feedback, {:user_id => @recommendee.id, :id => @recommendation.to_param, :recommendation => {'feedback_text' => 'text'}}
      assigns(:recommendation).should eq(@recommendation)
      assigns(:recommendation).status.should eq(Recommendation::STATUS_DONE)
    end

    it "updates the requested recommendation as pending if feedback was not given or empty" do
      sign_in @recommender
      post :submit_feedback, {:user_id => @recommendee.id, :id => @recommendation.to_param, :recommendation => {'feedback_text' => ''}}
      assigns(:recommendation).should eq(@recommendation)
      assigns(:recommendation).status.should eq(Recommendation::STATUS_PENDING)
    end

    it "assigns the requested recommendation as @recommendation for recommender" do
      sign_in @recommender
      post :submit_feedback, {:user_id => @recommendee.id, :id => @recommendation.to_param, :recommendation => {'feedback_text' => 'text'}}
      assigns(:recommendation).should eq(@recommendation)
    end

    it "redirects to current_user recommendations list" do
      sign_in @recommender
      post :submit_feedback, {:user_id => @recommendee.id, :id => @recommendation.to_param, :recommendation => {'feedback_text' => 'text'}}
      response.should redirect_to(user_recommendations_path(@recommender))
    end

    it "should redirect back to recommendee recommendations url if he/she try to give feedback on his own recommendation" do
      sign_in @recommendee
      post :submit_feedback, {:user_id => @recommendee.id, :id => @recommendation.to_param}
      assigns(:can_access).should eq(false)
      response.should redirect_to( user_recommendations_path(@recommendee))
    end
  end

  describe "POST create" do
    
    before(:each) do
      @recommendee = Factory(:confirmed_user)
      sign_in @recommendee
    end

    it "should redirect back to current_user recommendations url if he/she try to create recommendation for different user" do
      @user = Factory(:confirmed_user)
      sign_in @user
      post :create, {:user_id => @recommendee.id, :recommendation => valid_attributes }
      assigns(:can_access).should eq(false)
      response.should redirect_to( user_recommendations_path(@user))
    end
    
    describe "with valid params" do
      it "creates a new Recommendation" do
        expect {
          post :create, {:user_id => @recommendee.id, :recommendation => valid_attributes }
        }.to change(Recommendation, :count).by(1)
      end

      it "assigns a newly created recommendation as @recommendation" do
        post :create, {:user_id => @recommendee.id, :recommendation => valid_attributes }
        assigns(:recommendation).should be_a(Recommendation)
        assigns(:recommendation).should be_persisted
        assigns(:recommendation).recommendee.should eq(@recommendee)
      end

      it "redirects to current_user recommendations list" do
        post :create, {:user_id => @recommendee.id, :recommendation => valid_attributes }
        response.should redirect_to( user_recommendations_path(@recommendee))
      end
    end

    describe "with invalid params" do
      it "assigns a newly created but unsaved recommendation as @recommendation" do
        post :create, {:user_id => @recommendee.id, :recommendation => {} }
        assigns(:recommendation).should be_a_new(Recommendation)
      end

      it "re-renders the 'new' template" do
        post :create, {:user_id => @recommendee.id, :recommendation => {} }
        response.should render_template("new")
      end
    end
  end



  describe "DELETE destroy" do

    before(:each) do
      @recommendation = Factory(:recommendation)
      @recommendee = Factory(:confirmed_user)
      @recommender = Factory(:confirmed_user)
      @recommendation.recommendee =  @recommendee
      @recommendation.recommender = @recommender
      @recommendation.save(:validate => false)
    end

    it "destroys the requested recommendation if current_user is recommendee" do
      expect {
        sign_in @recommendee
        delete :destroy, {:user_id => @recommendee.id, :id => @recommendation.to_param}
      }.to change(Recommendation, :count).by(-1)
    end

    it "destroys the requested recommendation if current_user is recommender" do
      expect {
        sign_in @recommender
        delete :destroy, {:user_id => @recommendee.id, :id => @recommendation.to_param}
      }.to change(Recommendation, :count).by(-1)
    end

    it "redirects to current_user recommendations list" do
      sign_in @recommendee
      delete :destroy, {:user_id => @recommendee.id, :id => @recommendation.to_param}
      response.should redirect_to(user_recommendations_path(@recommendee))
    end

    it "should not destroy the requested recommendation if current_user is not a recommendee or recommender" do
      @user = Factory(:confirmed_user)
      sign_in @user
      delete :destroy, {:user_id => @recommendee.id, :id => @recommendation.to_param}
      assigns(:recommendation).should be_persisted
      response.should redirect_to(user_recommendations_path(@user))
    end
    
  end

end
